# LAB1 
- In the code we used 3 algorithms for solving the problem with the best results
- our nodes are basically the lists generated by the function `problem` and they are mutually execlusive
- we pass the Number of elements N and the list generated with our nodes to each algorithm

- in each algorithm we "rank" each node and that is by estimating the cost of each node based on the number of elements covered by each node 
for example the node ` [1,2,5,2] ` has a rank of `3` because it covers ` 3 ` elements ` 1,2,5`


## Breadth first algorithm:
- in this algorithm we first search in the nodes with the least number of costs by ordering the nodes and start the search 
- as a result we visit too many nodes to get our solution

## Depth first algorithm:
- we sort the nodes in an ascending order and then start another order such that
example :-
```
[1,2,3,4,5] rank 5
[0,5,2,4,6] rank 5
[0,1,2,4]   rank 4
[2,3,1]     rank 3
[5,2,3]     rank 3
```
the order will be
```
[5,2,3]     rank 3
[0,1,2,4]   rank 4
[0,5,2,4,6] rank 5
[2,3,1]     rank 3
[1,2,3,4,5] rank 5
```
starting from the lowest cost and going up each time and then start over

## Gready best-first:
- here we start our solution with the node which covers most numbers
- and after that we rearrange the nodes based on the remaining numbers that are still not covered
- then we choose the node that covers the most numbers and rearrange ...
- and this is the most efficient solution that i use

## *Final solution is Gready best-first*


## *No external sources were used*

## *Results*
### Breadth first Algorithm
```
For N = 5 => the list has a weight W = 5 and we used 5 nodes to cover it
For N = 10 => the list has a weight W = 13 and we used 7 nodes to cover it
For N = 20 => the list has a weight W = 46 and we used 12 nodes to cover it
For N = 100 => the list has a weight W = 332 and we used 19 nodes to cover it
For N = 500 => the list has a weight W = 2162 and we used 24 nodes to cover it
For N = 1000 => the list has a weight W = 4652 and we used 26 nodes to cover it
```
### Depth first Algorithm
```
For N = 5 => the list has a weight W = 6 and we used 4 nodes to cover it
For N = 10 => the list has a weight W = 18 and we used 6 nodes to cover it
For N = 20 => the list has a weight W = 47 and we used 8 nodes to cover it
For N = 100 => the list has a weight W = 335 and we used 14 nodes to cover it
For N = 500 => the list has a weight W = 2392 and we used 24 nodes to cover it
For N = 1000 => the list has a weight W = 5307 and we used 28 nodes to cover it
```
### Greedy best-first Algorithm
```
For N = 5 => the list has a weight W = 6 and we used 3 nodes to cover it
For N = 10 => the list has a weight W = 13 and we used 3 nodes to cover it
For N = 20 => the list has a weight W = 32 and we used 4 nodes to cover it
For N = 100 => the list has a weight W = 191 and we used 5 nodes to cover it
For N = 500 => the list has a weight W = 1375 and we used 7 nodes to cover it
For N = 1000 => the list has a weight W = 3087 and we used 8 nodes to cover it
```
