# LAB1 
- In the code we used 3 algorithms for solving the problem with the best results
- our nodes are basically the lists generated by the function `problem` and they are mutually execlusive
- we pass the Number of elements N and the list generated with our nodes to each algorithm

- in each algorithm we "rank" each node and that is by estimating the cost of each node based on the number of elements covered by each node 
for example the node ` [1,2,5,2] ` has a rank of `3` because it covers ` 3 ` elements ` 1,2,5`


## Breadth first algorithm:
- in this algorithm we first search in the nodes with the least number of costs by ordering the nodes and start the search 
- as a result we visit too many nodes to get our solution

## Depth first algorithm:
- we sort the nodes in an ascending order and then start another order such that
example :-
```
[1,2,3,4,5] rank 5
[0,5,2,4,6] rank 5
[0,1,2,4]   rank 4
[2,3,1]     rank 3
[5,2,3]     rank 3
```
the order will be
```
[5,2,3]     rank 3
[0,1,2,4]   rank 4
[0,5,2,4,6] rank 5
[2,3,1]     rank 3
[1,2,3,4,5] rank 5
```
starting from the lowest cost and going up each time and then start over

## Gready best-first:
- here we start our solution with the node which covers most numbers
- and after that we rearrange the nodes based on the remaining numbers that are still not covered
- then we choose the node that covers the most numbers and rearrange ...
- and this is the most efficient solution that i use

## *Final solution is Gready best-first*


## *No external sources were used*